- Converted PostgreSQL Schema to SQLite

-- -----------------------------------------------------------------------------
-- Notes on Conversion:
-- 1. ENUM Types: SQLite does not have a native ENUM type.
--    The PostgreSQL ENUMs ('season_enum', 'term_collection_status_enum') have
--    been converted to TEXT columns with a CHECK constraint to simulate
--    the same behavior.
-- 2. JSONB Type: SQLite does not have a JSONB type. The 'jsonb' columns
--    have been converted to TEXT. A CHECK(json_valid(column_name))
--    constraint has been added to ensure the text stored is valid JSON.
-- 3. Regex Constraints: PostgreSQL's regex matching operator (~) is not
--    available in SQLite. The CHECK constraints using regex have been
--    removed. Application-level validation is recommended for these fields.
-- 4. Data Types:
--    - BOOL is converted to INTEGER with a CHECK constraint (0 for false, 1 for true).
--    - TIMESTAMP and TIME are converted to TEXT. It's common to store dates/times
--      as ISO8601 strings ('YYYY-MM-DD HH:MM:SS.SSS').
-- 5. Foreign Keys: Foreign key constraints, including composite keys and
--    'ON DELETE CASCADE', are supported in SQLite and have been preserved.
--    Note: `PRAGMA foreign_keys = ON;` must be executed for each connection
--    to enforce foreign key constraints in SQLite.
-- -----------------------------------------------------------------------------


-- Table: schools
CREATE TABLE schools (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL
    -- The PostgreSQL constraint `id ~ '^[a-zA-Z]*$'` has been removed.
    -- SQLite does not have a built-in regex constraint like this.
    -- This check should be handled at the application level.
);

-- Table: terms
CREATE TABLE terms (
    year INTEGER,
    season TEXT CHECK( season IN ('Spring', 'Fall', 'Winter', 'Summer') ), -- Replaces season_enum

    PRIMARY KEY (year, season)
);

-- Table: term_collections
CREATE TABLE term_collections (
    id TEXT,
    school_id TEXT,

    year INTEGER NOT NULL,
    season TEXT NOT NULL CHECK( season IN ('Spring', 'Fall', 'Winter', 'Summer') ), -- Replaces season_enum
    name TEXT,
    still_collecting INTEGER NOT NULL CHECK(still_collecting IN (0, 1)), -- Replaces BOOL
    FOREIGN KEY (school_id) REFERENCES schools(id),
    FOREIGN KEY (year, season) REFERENCES terms(year, season),
    PRIMARY KEY (id, school_id)
    -- The PostgreSQL constraint `id ~ '^[a-zA-Z0-9]*$'` has been removed.
    -- This check should be handled at the application level.
);

-- Table: professors
CREATE TABLE professors (
    id TEXT,
    school_id TEXT,

    name TEXT NOT NULL,
    email_address TEXT,
    first_name TEXT,
    last_name TEXT,
    other TEXT, -- This column should contain valid JSON.
    FOREIGN KEY (school_id) REFERENCES schools(id),
    PRIMARY KEY (id, school_id),
    CHECK(other IS NULL OR json_valid(other)) -- Ensures 'other' is valid JSON if not NULL
);


-- Table: courses
CREATE TABLE courses (
    school_id TEXT,
    subject_code TEXT,
    number TEXT,

    subject_description TEXT,
    title TEXT,
    description TEXT,
    credit_hours REAL NOT NULL,
    prerequisites TEXT,
    corequisites TEXT,
    other TEXT, -- This column should contain valid JSON.

    FOREIGN KEY (school_id) REFERENCES schools(id),
    PRIMARY KEY (school_id, subject_code, number),
    CHECK(other IS NULL OR json_valid(other)) -- Ensures 'other' is valid JSON if not NULL
    -- The PostgreSQL constraints on `subject_code` and `number` using regex
    -- have been removed and should be handled at the application level.
);


-- Table: sections
CREATE TABLE sections (
    sequence TEXT,
    term_collection_id TEXT,
    subject_code TEXT,
    course_number TEXT,
    school_id TEXT,

    max_enrollment INTEGER,
    instruction_method TEXT,
    campus TEXT,
    enrollment INTEGER,
    primary_professor_id TEXT,
    other TEXT, -- This column should contain valid JSON.
    FOREIGN KEY (school_id, subject_code, course_number)
        REFERENCES courses(school_id, subject_code, number),
    FOREIGN KEY (primary_professor_id, school_id) REFERENCES professors(id, school_id),
    FOREIGN KEY (term_collection_id, school_id) REFERENCES term_collections(id, school_id),
    PRIMARY KEY (sequence, term_collection_id, subject_code, course_number, school_id),
    CHECK(other IS NULL OR json_valid(other)) -- Ensures 'other' is valid JSON if not NULL
    -- The PostgreSQL constraint on `sequence` using regex has been removed
    -- and should be handled at the application level.
);

-- Table: meeting_times
CREATE TABLE meeting_times (
    sequence INTEGER,
    section_sequence TEXT,
    term_collection_id TEXT,
    subject_code TEXT,
    course_number TEXT,
    school_id TEXT,

    start_date TEXT, -- Replaces TIMESTAMP, store as 'YYYY-MM-DD HH:MM:SS'
    end_date TEXT,   -- Replaces TIMESTAMP, store as 'YYYY-MM-DD HH:MM:SS'
    meeting_type TEXT,
    start_minutes TEXT, -- Replaces TIME, store as 'HH:MM:SS'
    end_minutes TEXT,   -- Replaces TIME, store as 'HH:MM:SS'
    is_monday INTEGER NOT NULL CHECK(is_monday IN (0, 1)),
    is_tuesday INTEGER NOT NULL CHECK(is_tuesday IN (0, 1)),
    is_wednesday INTEGER NOT NULL CHECK(is_wednesday IN (0, 1)),
    is_thursday INTEGER NOT NULL CHECK(is_thursday IN (0, 1)),
    is_friday INTEGER NOT NULL CHECK(is_friday IN (0, 1)),
    is_saturday INTEGER NOT NULL CHECK(is_saturday IN (0, 1)),
    is_sunday INTEGER NOT NULL CHECK(is_sunday IN (0, 1)),
    other TEXT, -- This column should contain valid JSON.

    FOREIGN KEY (section_sequence, term_collection_id, school_id, subject_code, course_number)
        REFERENCES sections(sequence, term_collection_id, school_id, subject_code, course_number) ON DELETE CASCADE,
    PRIMARY KEY (sequence, section_sequence, term_collection_id, subject_code, course_number, school_id),
    CHECK(other IS NULL OR json_valid(other)) -- Ensures 'other' is valid JSON if not NULL
);
